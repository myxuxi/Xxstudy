# Xxstudy
并发编程
======
1.package p2.wn
----
(1)文件夹中的p2.wn是wait/notify/notifyAll的example，假设有Express类，里面有km和site两个属性，当km>100或者是site=BeiJing时进行通知，
在等待方法中进行判断，条件符合则进行业务逻辑处理。<br>
(2)在Test类中分别实现检查km和site的线程，最后调用改变km或者是site方法，如果change使用的是notify，则只会在所有线程中找到一个进行通知，
如果被通知的线程不符合，则继续wait，信号不会继续传输，如果使用notifyAll，则会通知所有线程，不符合的继续wait，符合的执行业务逻辑。

2.package forkjoin
----
(1)MakeArray中定义了一个数组，并赋予每一个元素随机值。<br>
(2)SumNormal类是一个单线程计算数组元素的累加总值，SumArray类是一个fork_join线程并发工具类，核心思想是分而治之，当问题规模小于一个阈值时可以直接解决，如果不行则把问题规模继续缩小。<br>
Fork/Join的标准范式如下：
![image](https://github.com/myxuxi/gzy/blob/master/forkjoin.png)
(3)如果中间没有Thread.sleep，那么使用单线程的效率更高，因为多线程使用CPU时的轮询机制，在线程切换间需要进行上下文切换，更加耗时。

3.package tools
----
(1)并发工具中的CountDownLatch,可以等待一个线程完全结束后再执行其它线程，加强版的join(),代码内容是先运行启动Spring全家桶的线程，再执行mysql线程，然后是主线程后再执行业务代码，定义CountDownLatch时要初始化count，需要先执行的线程执行后调用latch.countDown(),使count-1，当count=0时才可以执行await(),否则将一直等待。<br>
(2)并发工具中的CyclicBarrier,指的是屏障阻塞了一组线程，需要等待所有的线程到达后才能继续执行，与CountDownLatch的区别是CountDownLatch的放行是由第三者控制的，CyclicBarrier放行是由一组线程本身控制的，前者放行条件>=线程数，后者放行条件=线程数。

4.package Semaphore
----
(1)类SqlSession主要实现了数据库Connection方法，DBPoolSemaphore是数据库连接池的实现，包括连接池初始化，从数据库连接池拿资源和归还资源的操作，tips(在执行相应的操作时注意给连接池加锁，因为对应的业务场景是多线程的)。<br>
(2)在AppTest中模拟业务场景中的使用数据库连接池查询数据库，并做了50个线程的多线程环境，因为有10个连接池资源，所以前10个使用连接池的资源不需要等待，后面的40个则需要等待且等待时间会越来越长，类似阻塞状态，最后使用完并归还连接池资源。tips（acquire是消费许可，release是创建许可）

5.package rw
----
分别使用synchronized和ReadWriteLock来测试查找商品和出售商品所用的时间，测试结果为读写锁的效率较高，适合读写锁的场景是读多写少的情况，同一时刻允许多个读线程同时访问，但是在写线程访问的时候，所有的读写都被阻塞。

6.package bitwise
----
这里主要是使用了位运算来操作用户拥有的权限，通过|&~等操作来设置，增加，取消，判断用户的权限，适用于多字段的场景，在数据库中存放太多字段修改时读写效率也较为低和不方便，在很多电商系统较为常见。

7.package bq
----
这里主要是使用了阻塞队列中的DelayQueue，它是一个优先级队列实现的无界阻塞队列。支持延时获取的元素的阻塞队列，元素必须要实现Delayed接口。适用场景：实现自己的缓存系统，订单到期，限时支付等等。这里主要模拟的是订单到期的业务场景，在ItemVo中实现Delayed接口，分别实现了返回时间剩余时长和按照剩余时间排序的方法，然后有一个将订单放入队列的线程和一个提取订单的线程，让它们实现订单到期后从队列中拿出的场景，可应用于生产环境。


JVM
====
1.四大引用
----
(1)强引用：程序普遍存在的引用赋值，类似Object obj = new Object()，只要强引用关系存在，垃圾收集器就永远不会回收掉被引用的对象。<br>
(2)软引用：描述一些还有用但非必须的对象，只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。<br>
(3)弱引用：也是描述非必须对象，强度比软引用更弱，它关联的对象只能生存到下次垃圾收集发生为止，当垃圾收集器开始工作时，无论内容是否足够，都会回收掉只被弱引用关联的对象。<br>
(4)虚引用：一个对象是否有虚引用的存在，都不会对它的生存时间构成影响，也不能通过它来获得对象实例，它的唯一目的就是对象被收集器回收时收到一个系统的通知。
